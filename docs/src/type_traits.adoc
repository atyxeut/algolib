= src/type_traits.hpp

Backports part of the standard header `<type_traits>` to C++11 and provides custom traits.

== Required includes

Standard headers: `<type_traits>`, `<utility>`.

Custom headers: `src/aliases.hpp`.

== Content

=== `aal::bool_constant`

Same as C++17 `std::bool_constant`.

=== `aal::size_t_constant`

Similar to `aal::bool_constant`, `aal::size_t_constant<I>` is equivalent to `std::integral_constant<size_t, I>`.

=== `aal::enable_if_t` and `aal::t_enable_if_t`

Same as C++14 `std::enable_if_t`, except that the latter's first template parameter is a type parameter,
of which the given type must have a member constant `value` that is convertible to `bool`.

=== `aal::conditional_t` and `aal::t_conditional_t`

Same as C++14 `std::conditional_t`, except that the latter's first template parameter is a type parameter,
of which the given type must have a member constant `value` that is convertible to `bool`.

=== `aal::type_identity` and `aal::type_identity_t`

Same as C++20 `std::type_identity` and `std::type_identity_t`.

=== `aal::void_t`

Same as C++17 `std::void_t`.

=== `aal::common_type_t`

Same as C++14 `std::common_type_t`.

=== `aal::remove_cv_t` and `aal::remove_ref_t`

Same as C++14 `std::remove_cv_t` and `std::remove_reference_t`.

=== `aal::remove_cvref` and `aal::remove_cvref_t`

Same as C++20 `std::remove_cvref` and `std::remove_cvref_t`.

=== `aal::add_cv_t`, `aal::add_const_t` and `aal::add_volatile_t`

Same as C++14 `std::add_cv_t`, `std::add_const_t` and `std::add_volatile_t`.

=== `aal::add_lref_t` and `aal::add_rref_t`

Same as C++14 `std::add_lvalue_reference_t` and `std::add_rvalue_reference_t`.

=== `aal::negation`

Same as C++17 `std::negation`.

Helper variable template `aal::negation_v` is available since C++14.

=== `aal::conjunction`

Same as C++17 `std::conjunction`.

Helper variable template `aal::conjunction_v` is available since C++14.

=== `aal::disjunction`

Same as C++17 `std::disjunction`.

Helper variable template `aal::disjunction_v` is available since C++14.

=== `aal::is_bool`

Checks if the given type is (cv-qualified) `bool`.

Helper variable template `aal::is_bool_v` is available since C++14.

=== `aal::is_cv`

The conjunction of `std::is_const` and `std::is_volatile`.

Helper variable template `aal::is_cv_v` is available since C++14.

=== `aal::claim_cv`
Extracts the cv-qualifiers of a type and apply them to another type.

Its helper alias template is `aal::claim_cv_t`.

==== Example

[source, C++]
----
using T = aal::claim_cv_t<const volatile int, long long>; // T is const volatile long long
using Y = aal::claim_cv_t<char, int>; // Y is int
----

=== `aal::is_none_of`

Checks if neither of the other given types is the same as the first given type.

Helper variable template `aal::is_none_of_v` is available since C++14.

==== Example

[source, C++]
----
constexpr bool t1 = aal::is_none_of<int, long long, bool, char, void>; // t1 is true
constexpr bool t2 = aal::is_none_of<int, long long, bool, char, void, int>; // t2 is false
----

=== `aal::is_any_of`

The negation of `aal::is_none_of`.

Helper variable template `aal::is_any_of_v` is available since C++14.

=== `aal::is_int128`

Checks if the given type is (cv-qualified) `i128` or `u128`.

Helper variable template `aal::is_int128_v` is available since C++14.

=== `aal::is_integral`

The disjunction of `std::is_integral` and `aal::is_int128`. So it always considers (cv-qualified) `i128` and `u128` as integer types.

Helper variable template `aal::is_integral_v` is available since C++14.

=== `aal::is_standard_integral`

Checks if the given type satisfies `std::is_integral` but not `aal::is_int128`.

This trait is added because `std::is_integral_v<i/u128>` is true in `-std=gnu++` mode, which may not always be the desired result.

Helper variable template `aal::is_standard_integral_v` is available since C++14.

=== `aal::is_nonbool_integral`

Checks if the given type satisfies `aal::is_integral` but not `aal::is_bool`.

Helper variable template `aal::is_standard_integral_v` is available since C++14.

=== `aal::make_signed` and `aal::make_unsigned`

Adds `i/u128` support to `std::make_signed` and `std::make_unsigned`.

`aal::is_nonbool_integral` is implicitly required.

Their helper alias templates are `aal::make_signed_t` and `aal::make_unsigned_t`.

=== `aal::is_signed` and `aal::is_unsigned`

Adds `i/u128` support to `std::is_signed` and `std::is_unsigned`.

Helper variable templates `aal::is_signed_v` and `aal::is_unsigned_v` are available since C++14.

=== `aal::is_nonbool_unsigned`

Checks if the given type satisfies `aal::is_unsigned` but not `aal::is_bool`.

Helper variable template `aal::is_nonbool_unsigned_v` is available since C++14.

=== `aal::is_f128`

Checks if the given type is (cv-qualified) `f128`.

Helper variable template `aal::is_f128_v` is available since C++14.

=== `aal::is_floating_point`

The disjunction of `std::is_floating_point` and `aal::is_f128`. So it always considers (cv-qualified) `f128` as a floating-point type.

Helper variable template `aal::is_floating_point_v` is available since C++14.

=== `aal::is_standard_floating_point`

Checks if the given type satisfies `std::is_floating_point` but not `aal::is_f128`.

This trait is added because `std::is_floating_point_v<f128>` is true in `-std=gnu++` mode, which may not always be the desired result.

Helper variable template `aal::is_standard_floating_point_v` is available since C++14.

=== `aal::make_larger_width`

For the given integer type, obtains `i32` if its width is smaller than the width of `i32`, otherwise
obtains an integer type with double width. If the given type already has the largest width, then obtain the type itself.
cv-qualifiers and signedness are kept.

Its helper alias template is `aal::make_larger_width_t`.

==== Example

[source, C++]
----
using T = aal::make_larger_width_t<unsigned char>; // T is u32
using Y = aal::make_larger_width_t<i128>; // Y is i128
----

=== `aal::make_higher_precision`

For the given floating-point type, obtains `f64` if it is `f32`, obtains `f80` if it is `f64`, obtains `f128` if it is `f80`,
and obtains `f128` if it is `f128`. cv-qualifiers are kept.

Its helper alias template is `aal::make_higher_precision_t`.

=== `aal::idiv_result`

Obtains the most suitable result type for the result of integer divisions.
cv-qualifiers of the operands' types are removed. See the code comments for implementation details.

Its helper alias template is `aal::idiv_result_t`.

==== Example

[source, C++]
----
using T = aal::idiv_result_t<int, int>; // T is long long
using T2 = aal::idiv_result_t<int, unsigned int>; // T2 is int
using T3 = aal::idiv_result_t<unsigned int, int>; // T3 is long long
----

=== `aal::integral_wrapper`

An incomplete type to wrap integer types.

=== `aal::unwrap_integral`

Extracts the type from a `aal::integral_wrapper`.

Its helper alias template is `aal::unwrap_integral_t`.