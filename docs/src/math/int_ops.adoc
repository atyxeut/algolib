= src/math/int_ops.hpp
:stem:

Provides various helper functions for integer operations.

== Required includes

Custom headers: `src/math/overflow_detection.hpp`.

== Content

=== `aal::iabs` (`constexpr`, `noexcept`)

Similar to integral versions of `std::abs`, but supports unsigned integers and 128-bit integers, and the result is returned in the corresponding unsigned type.

==== Example

[source, C++]
----
// 2147483648, no signed int overflow
unsigned int t = aal::iabs(-2147483647 - 1);
----

==== Rationales

Let asciimath:[n] be an negative integer, if the bit representation of asciimath:[n] is two's complement, then `~n + 1`
is the absolute value of asciimath:[n], i.e. asciimath:[-n]. To avoid overflow when asciimath:[n] has the signed minimum value,
we need to cast the type to unsigned first.

Luckily, GCC's implementation always uses two's complement, and preserves the original bit patterns during signed-unsigned conversions,
see link:https://gcc.gnu.org/onlinedocs/gcc/Integers-implementation.html[this] (this becomes standard since C++20).
