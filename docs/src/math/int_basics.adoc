= src/math/int_basics.hpp
:stem:

Provides helper functions for integer arithmetics.

== Required includes

Custom headers: `src/math/overflow_detection.hpp`.

== Content

=== `aal::iabs` (`constexpr`, `noexcept`)

Similar to integral versions of `std::abs`, but supports unsigned integers and 128-bit integers.

The return type is always unsigned, thus unlike `std::abs`, it never overflows.

.Example
[source, C++]
----
// 2147483648, no signed int overflow
unsigned int t = aal::iabs(-2147483647 - 1);
----

==== Correctness

Let asciimath:[n] be an negative integer, if the bit representation of asciimath:[n] is two's complement, then `~n + 1`
is the absolute value of asciimath:[n], i.e. asciimath:[-n]. To avoid overflow when asciimath:[n] has the signed minimum value,
we need to cast the type to unsigned first.

Luckily, GCC's implementation always uses two's complement, and preserves the original bit patterns during signed-unsigned conversions,
see link:https://gcc.gnu.org/onlinedocs/gcc/Integers-implementation.html[this]. By the way, this becomes standard since C++20.

