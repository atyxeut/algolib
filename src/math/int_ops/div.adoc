= src/math/int_ops/div.hpp
:stem:

Provides functions `aal::idiv_floor` and `aal::idiv_ceil` (both `constexpr` since C++14, `noexcept`) to compute
asciimath:[floor(a / b)] and asciimath:[ceil(a / b)] for integers asciimath:[a, b] without introducing floating-point numbers.

These functions can correctly handle operands that have different width and signedness.

== Example

[source, C++]
----
int ans = aal::idiv_floor(5, 2)  // 2
int ans = aal::idiv_floor(-5, 2) // -3
long long ans = aal::idiv_floor(-2147483648, -1)  // 2147483648, no overflow
int ans = aal::idiv_floor(-2147483648, 1u)        // -2147483648, also no overflow
int ans = aal::idiv_ceil(5, 2)   // 3
int ans = aal::idiv_ceil(-5, 2)  // -2
----

== Undefined behaviors (will be detected if macro `NDEBUG` is not defined)

If the second arguments is 0, the behavior is undefined.

If the result cannot be represented by the return type, the behavior is undefined (see code comments for details).

== Rationales

Let asciimath:[a, b, q, r] be the dividend, divisor, quotient and remainder respectively.
With the theorem of link:https://en.wikipedia.org/wiki/Euclidean_division[Euclidean division],
we learn that asciimath:[q = floor(a / b)],
thus asciimath:[a b >= 0 rArr q >= 0] and asciimath:[a b < 0 rArr q < 0]. Furthur more,
if asciimath:[a b >= 0], or asciimath:[a b < 0] and asciimath:[b | a],
then asciimath:[abs(q) = floor(abs(a) / abs(b))];
if asciimath:[a b < 0] and latexmath:[b \nmid a], then asciimath:[abs(q) = floor(abs(a) / abs(b)) + 1].
So the most convenient and universal method is to calculate asciimath:[|q|] then derive the answer from it,
and this is the implemented algorithm.

When executing `a / b` in C++, the build-in `/` operator automatically drops the fractional part of the quotient,
that is to say, it performs flooring, ceiling on the quotient when asciimath:[a b > 0], asciimath:[a b < 0].
As a result, there are also special methods that only apply to a limited range of integers.

=== A special method for asciimath:[floor(a / b)] when asciimath:[a b < 0]

Let asciimath:[q = floor(a / b)], if asciimath:[a < 0] and asciimath:[b > 0], then asciimath:[q = ceil((a + 1 - b) / b)];
if asciimath:[a > 0] and asciimath:[b < 0], then asciimath:[q = ceil((a - 1 - b) / b)].

==== Proof

Under the hypothesis, asciimath:[a + 1 - b] is guaranteed to be negative, thus `(a + 1 - b) / b` in C++ performs ceiling on the quotient.

Write asciimath:[a = k b + r] for some integers asciimath:[k, r] such that asciimath:[k < 0] and asciimath:[0 <= r < b], then

[asciimath]
++++
q = ceil(((k - 1)b + r + 1) / b) = k - 1 + ceil((r + 1)/ b).
++++

Therefore asciimath:[q = k], since asciimath:[1 <= r + 1 < b + 1 => 0 < r + 1 <= b => 0 < (r + 1) / b <= 1] always holds.

For the case when asciimath:[a > 0] and asciimath:[b < 0],
we can prove it by replacing asciimath:[a, b] with latexmath:[-a, -b] in the former formula.
The ceiling operation is still guaranteed, since asciimath:[a - 1 - b > 0] for asciimath:[a > 0] and asciimath:[b < 0].

=== A special method for asciimath:[ceil(a / b)] when asciimath:[a b > 0]

Let asciimath:[q = ceil(a / b)], if asciimath:[a > 0] and asciimath:[b > 0], then asciimath:[q = floor((a - 1 + b) / b)];
if asciimath:[a < 0] and asciimath:[b < 0], asciimath:[q = floor((a + 1 + b) / b)].

==== Proof

Under the hypothesis, asciimath:[a - 1 + b > 0] is guaranteed, so `(a - 1 + b) / b` in C++ performs flooring on the quotient.

Write asciimath:[a = k b + r] for some integers asciimath:[k, r] such that asciimath:[k >= 0] and asciimath:[0 <= r < b], then

[asciimath]
++++
q = floor(((k + 1)b + r - 1) / b) = k + floor((b + r - 1) / b).
++++

If latexmath:[b \mid a], then asciimath:[r = 0 => b - 1 <= b + r - 1 < 2b - 1 => 0 <= (b + r - 1) / b <= 1 => q = k].

If latexmath:[b \nmid a], then asciimath:[r >= 1 => b <= b + r - 1 < 2b => 1 <= (b + r - 1) / b < 2 => q = k + 1].

For the case when asciimath:[a < 0] and asciimath:[b < 0], we can proof it by replacing
asciimath:[a, b] with latexmath:[-a, -b] in the former fomula.
The flooring operation is still guaranteed, since asciimath:[a + 1 + b < 0] for asciimath:[a < 0] and asciimath:[b < 0].
